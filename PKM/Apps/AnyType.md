
[[PKM/Apps/AnyType]] 竟然没有 #Tag 意义上的 #Tag...
> 确实有 tag，但...竟然是个 field ！其 value 为多选 list ！...天才..
- AnyType 的 building atom 直接就是 具象对象的基类 下的 具象对象本身，中间没有 #Tag 隔一层... 实例化对象 直接继承了 对象基类的 field... 这意味着 对象的基类，起到了 `#Tag (的 base type)` 的作用 
- ==另一种理解方式==：AnyType 有 #Tag 意义上的 #Tag:
  - 对象类型 object('s) type，证据有 三：
    1. 你点一下 sidebar 的类型，就 List 同类型下的 所有 ==实例化对象==。
    2. 点对象的 _关联图_ ，会发现 `类型` 也作为 `对象`，与 对象 平权地 放在 graph view 上。所有链接到 类型 的边与节点的集合，全都构成 [[Wikipedia/有向图|星形状拓扑]]，而这正是 #Tag 相对于 wiki 织成的网 的区别。
       - 点 _流程图_ 会发现，还有 链入（反链）和 链出（正链）对象集合..
       - 此外，只要对象 key 的 value 是对象，就有 上述 链出（正链）们
       - 并且这些 链出（正链）们，作为带 key 名的箭头（而不仅仅是无名的边），出现在 _关联图_ 中（ _流程图_ 中暂时没有 key 名）
    3. 逻辑上，对象 is（其基类）类型。而凡是 is 就是 #Tag
     > 所以 AnyType 的 object 类型 type 等价于 #Tag
  - 可以新建 对象类型，自定义 该类型对应的模板、默认属性
    - 类型 Type 的模板（的排版）
      - 看上去就是 `#Tag 的 base type`（的具体布局/外观）？
      - 不是...如果有 #Tag 就没有 `#Tag 的 base type`。
      - 模板本身 等价于 SilverBullet 的 tag，它属于 tags 中的 一员。
        - 只不过 AnyType 中的模板 是 SilverBullet 中许多 tag 的 排版到 同一个页面 的结果。
        - 
  - 任何一个对象，只能被分配到某一个 对象类型（只能有一个 #Tag 和 一个默认模板布局）。
    - 对象可以选择继承 类型的 模板，也可以选择 用自己实例的不同模板
      - 对象页面的现有布局，可以点页面右上角 三个点，然后“用作模板”
        - 就会使 ==对象的模板== 升格为 对象对应的 ==类型的模板==
    - 对象可以有额外的 自己的属性
      - `对象的 在类型属性以外的 额外属性`，会在类型页面自动 query 出来，可以被拖选并添加进 `类型的 default 属性`

在不点开 对象页面 的 右上角 ℹ 的情况下，
页面的 属性值 value 的 填写，是在 page name 下方，
对象类型 右侧，横着的一排 填空题。
- 填前显示 keys，填后只显示 values。
  - 对于某个key,有多个 value 时，只显示第一个 value ，
    - 其他显示为 “+(n-1)”，即除了第一个 value 剩下的 n-1 个 值
- 这和 LogSeq 和 Tana 的 竖着填写 的逻辑 不一样。

