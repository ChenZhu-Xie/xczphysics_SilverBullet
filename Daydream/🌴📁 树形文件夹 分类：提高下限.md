#tree #info

# 今天我沿用传统的文件夹方式，整理了一下社区的插件，

## 竟发现了 2 个传统文件夹方式的好处：

1. 把 [[CONFIG/Widget/Journal/Navigation]] 的 路径 `CONFIG/Widget/Journal/Navigation` 读完，才是末级 .md 文件 的 完整 文件名
   - 这意味着 可以省略 末级文件名 `Navigation` 长度
     - 将其 信息量，藏进 其前面的 文件夹名 `CONFIG/Widget/Journal/` 中
   - 在命名（完整）文件名 的 同时，就已经在进行（树状）分类

2. 功能不同的插件，末级文件名不同。但这些文件的功能在某种程度上相似。
   - 这在 AI 时代被称为：语义相似度，对应的 word2vec 向量 的终点接近
   - 这不就正好对应了：这些文件，都在 文件树 的 某同一个枝丫末梢？

# 无标签 时，怎么 文件夹 分类，层数最少

比如 [[STYLE/Math/Symbol]] 最初是放在 `STYLE/Font/` 下的，当时也理应放在其下。

然而，好景不长，加入了 [[STYLE/Math/Katex]]。
若不受外界干扰，其初始状态，其实也本应该 放在 `STYLE/Widget/` 下，但...

随着 [[STYLE/Math/Katex]] 的加入，它与 [[STYLE/Math/Symbol]] 产生了 “关联”：
二者都与 数学符号 相关（尽管不严格就是）。

这立马暗示我们，推荐的分类变更为新的方法：
[[STYLE/Math/Katex]] 应与 [[STYLE/Math/Symbol]] 从各自的旧父目录中抽离出来，放在同一新目录 `STYLE/Math/` 下。

如此一来，原来分别在 `STYLE/Widget/` 和 `STYLE/Font/` 下的 孤立末级，
因 [[STYLE/Math/Symbol]] “突然有了新伴侣”，而 “比翼双飞” 到另一个 “世外桃源” 了。

- 这既减少了 `STYLE/Widget/(Math/)Katex` 和 `STYLE/Font/(Math/)Symbol` 的（未来）层级深度
- 又降低了 `STYLE/Widget/` 和 `STYLE/Font/` 当下的 未分类 = 孤立末级 数目
>   注：STYLE/Widget/ 和 STYLE/Font/ 中还有其他的，已形成 直属父文件夹 的 条目，所以称 Katex 和 Symbol 分别在各自的 dir 中 未形成 直属父 dir

## 归根结底：平行四边形 2 边通 Roman

- `STYLE/Widget/Katex` 和 `STYLE/Font/Symbol` 通过 #math 标签建立联系
- `STYLE/Math/Katex` 和 `STYLE/Math/Symbol` 通过 #Katex 和 #Font 标签
  - 与 旧父路径 `STYLE/Widget/` 和 `STYLE/Font/` 建立联系

## 标签系统，专门处理：交集非空，并集非全

如果 不允许 使用标签，只能使用 树状系统，那么只能通过上述 “实时的” 变通方法，减少 “永恒” 孤立末梢 数量、降低（未来 可能的）文件层级深度。
>  注：Katex 和 Symbol 与 旧父路径 `STYLE/Widget/` 和 `STYLE/Font/` 中的 任何对象 无法配对，并且 它们与后续这两个文件夹中 未来加入的末级 的 潜在配对概率 也很低，因此 称它们为「“永恒”孤立末梢」。

### 虎鲸

#### Orca 的作者 非常抵制 tree 文件夹分类方式，

并且 在产品设计哲学上力推一切皆标签，用标签来分类一切对象

但一方面 [[Daydream/🇵🇭🔨 Tana Philosophy#Tana 群友发言|它的 supertag 的 attr/property 继承逻辑 没有 tana 好]]
另一方面 它的任何页面（聚焦后的子块）的标题，均是[[当前日期（作为总块）⚓|当前日期（作为总块）🔙]]${backRefs("当前日期（作为总块）")}
   - 点击日期跳转到当日所有笔记列表
   - 强迫你用 # 标签 分类一切，以及用 @ 建立 wiki 关系网
     否则只能像 [[CONFIG/Search/Silver_Search]] 一样全文检索。
     - `Ctrl + k` 在不进行检索时，默认 list 竟是 ==最近访问的 对象们==！
       - 某种程度上，这一点 比我做的 [[Library/xczphysics/CONFIG/Mouse/History_+_Center|Click History]] 要好...
     - `Ctrl + k` 在进行检索后
       - 可以 匹配+预览 所有对象中的文本，但最终跳转后落脚的是对象
         - 与 @ 所引用的块 和 [[#自带 query 块|Live Query]] 所嵌入的块 一样，都是 对象
         - 这一点 和 思源 是一样的。
           - AnyType（内联查询）竟然 不支持 检索 每一个字...-_-||
       - [[CONFIG/Search/Silver_Search]] 也是全文检索，但落脚精确到光标位置
         - 尽管 `alt + enter` 插入的 链接只是 page 层级

#### 没有标题！

    不用、也不能，给任何块添加标题（它自己的内容已经 描述了自己）。
  - 因为 任何一个内容，既可以放入 a 收藏夹，也可以放入 b 收藏夹 -_-||

    但 接踵而至的一个问题是：分享后的笔记的 Url 怎么命名？
    像 Notekit 或 RoamEdit 一样用 block id 来命名？
    或 直接用 第一个块的内容？这样看不出来全文的凝炼核心。

#### 自带 query 块

- 而 SiYuan 只能通过 [[Daydream/💌⭐ 思源 v1：SilverBullet#思源 缺乏 live query?|插件]] 来将 query 嵌入 某块。
  - 这一点 Orca 继承了 Logseq
    - 但 Orca 也继承了 Logseq 的卡... -_-||

- SiYuan、Orca、Tana、SilverBullet 原则上都不能自动刷新 live query
  - 但 SilverBullet 可以 alt-q 快捷键 刷新所有的 live query
    - 但 SilverBullet 的查询结果是 ==引用==，而非==嵌入==（无法动态更新源）
  - 尽管 Orca 的 固定 condition 的 匹配/过滤 结果 list 没法自动刷新
    - 但 匹配/过滤 出的 每一个对象，是 实时刷新 的（Embed ==嵌入==的），并且可以直接更改，以更改对应的 源
    - 这一点 SilverBullet 似乎做不到
- #Logseq 的 live query 可以自动刷新（且应该是事件触发的）
  - 也很容易部署成 site：https://docs.logseq.com/
    - 不过是 ==静态的==，非 app
    - 有反链，但丢失了许多 原生 CMDs
      - 但 全局 Query 和 live query 都在
      - 作为对比，SB 即使只读，也会有一些 CMDs
    - `View as slides` 可以像 B 站 `绿导师原谅你了` 的 Slides 一样
      - 有 ←→↑↓ 方向箭头
      - #💡 我才知道 这样的 Slides 的本质 反映了 树状的结构... 

- Orca 的 live query 查询条件 无法隐藏...
  - 这使得在视觉上，没有 SB 简单

- Orac 的 live query 视图 除了列表，还有 日历
  - 看样子把 [[当前日期（作为总块）⚓|每日笔记🧑‍🤝‍🧑1]]${forthRef("当前日期（作为总块）")}${backRefs_noSelf("当前日期（作为总块）",1)} 做到极致了
